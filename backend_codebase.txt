
================================================================================
# Codebase: codebase #
================================================================================
File Path: /codebase\backend\src\index.ts

import "dotenv/config";
import express from "express";
import cors from "cors";
import morgan from "morgan";

import authRoutes from "./routes/auth";
import blogRoutes from "./routes/blogRoutes";
import timelineRoutes from "./routes/timelineRoutes";
import githubTrackerRoutes from "./routes/githubTracker";
import trackerRoute from "./routes/trackerRoute";
import domainRoute from "./routes/domainRoute";
import roadmapRouter from "./routes/roadmap.route";

import { connectProducer, sendEventToKafka } from "./utils/producer";
import { startKafkaConsumer, userCache } from "./services/kafkaConsumerService";
import { warmupKafkaCache } from "./utils/warmupKafka";

const app = express();

/* =====================================================
   Middleware Setup
===================================================== */
app.use(
  cors({
    origin: "http://localhost:3000",
    credentials: true,
  }),
);
app.use(express.json());
app.use(morgan("dev"));

/* =====================================================
   Routes
===================================================== */
app.use("/api", blogRoutes);
app.use("/auth", authRoutes);
app.use("/api", timelineRoutes);
app.use("/tracker", githubTrackerRoutes);
app.use("/tracker", trackerRoute);
app.use("/api", domainRoute);
app.use("/api/roadmap", roadmapRouter);
/* =====================================================
   Health Check Route
===================================================== */
app.get("/", (_req, res) => {
  res.send("âœ… Ascent Backend is Running!");
});

app.get("/kafka/test", async (_req, res) => {
  try {
    console.log("Testing Kafka send...");
    await sendEventToKafka(
      "student.blog.interest",
      "test-user",
      "debugFeature",
      { message: "Kafka test event" },
    );
    res.json({ ok: true, message: "Test event sent to Kafka" });
  } catch (err) {
    console.error("Kafka test failed:", err);
    res.status(500).json({ error: "Kafka test failed" });
  }
});

/* =====================================================
   ðŸš€ Start Server + Kafka Warmup
===================================================== */

const PORT = process.env.PORT || 5000;

app.listen(PORT, async () => {
  console.log(`Backend running at http://localhost:${PORT}`);

  // Step 1: Warmup cache before ANY real consumer starts
  await warmupKafkaCache();

  // Step 2: Start real-time shared consumer
  await startKafkaConsumer();

  // Step 3: Connect Kafka producer
  try {
    await connectProducer();
    await sendEventToKafka("system-logs", "server", "startup", {
      message: "Ascent backend started successfully",
    });

    console.log("Kafka producer connected and ready!");
  } catch (err) {
    console.error("Kafka initialization failed:", err);
  }
});

--------------------------------------------------------------------------------
File Path: /codebase\backend\src\controllers\roadmap.controller.ts

import { Request, Response } from "express";
import { prisma } from "../utils/prisma";
import { roadmapService } from "../services/roadmap.service";

export const generateRoadmap = async (req: Request, res: Response) => {
  try {
    const { query, model, apiKey, mode, userId } = req.body;

    // 1. Check for cached version
    const normalizedQuery = query.replace(/\s+/g, "").toLowerCase();
    const existing = await prisma.roadmap.findFirst({
      where: { title: { contains: normalizedQuery, mode: "insensitive" } },
    });

    if (existing) {
      await prisma.roadmap.update({
        where: { id: existing.id },
        data: { searchCount: { increment: 1 } },
      });
      return res.json({
        status: true,
        tree: JSON.parse(existing.content),
        roadmapId: existing.id,
      });
    }

    // 2. Credit check if using system mode
    const user = await prisma.user.findUnique({ where: { userId } });
    if (!user)
      return res.status(404).json({ status: false, message: "User not found" });

    if (mode === "credits" && user.roadmap_credits < 100) {
      return res
        .status(403)
        .json({ status: false, message: "Insufficient credits" });
    }

    // 3. Generate content
    const activeKey = mode === "personal" ? apiKey : process.env.GEMINI_API_KEY;
    const tree = await roadmapService.generateAIContent(
      query,
      activeKey,
      model || "gemini-3-flash-preview",
    );

    // 4. Atomic Update: Save roadmap and decrement credits
    const finalResult = await prisma.$transaction(async (tx) => {
      const saved = await tx.roadmap.create({
        data: {
          title: query,
          content: JSON.stringify(tree),
          userId: user.id,
        },
      });

      if (mode === "credits") {
        await tx.user.update({
          where: { userId },
          data: { roadmap_credits: { decrement: 100 } },
        });
      }
      return saved;
    });

    return res
      .status(200)
      .json({ status: true, tree, roadmapId: finalResult.id });
  } catch (error) {
    console.error("Express Roadmap Error:", error);
    return res
      .status(500)
      .json({ status: false, message: "Roadmap generation failed." });
  }
};

// send list of id,name of all roadmaps in database, sorted by createdAt desc
export const getAllRoadmaps = async (req: Request, res: Response) => {
  try {
    const roadmaps = await prisma.roadmap.findMany({
      select: { id: true, title: true },
      orderBy: { createdAt: "desc" },
    });
    return res.status(200).json({ status: true, roadmaps });
  } catch (error) {
    console.error("Express Get All Roadmaps Error:", error);
    return res
      .status(500)
      .json({ status: false, message: "Failed to fetch roadmaps." });
  }
};

// get roadmap by id
export const getRoadmapById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const roadmap = await prisma.roadmap.findUnique({ where: { id: Number(id) } });
    if (!roadmap)
      return res
        .status(404)
        .json({ status: false, message: "Roadmap not found." });
    return res
      .status(200)
      .json({
        status: true,
        roadmap: {
          id: roadmap.id,
          title: roadmap.title,
          content: JSON.parse(roadmap.content),
        },
      });
  } catch (error) {
    console.error("Express Get Roadmap By ID Error:", error);
    return res
      .status(500)
      .json({ status: false, message: "Failed to fetch roadmap." });
  }
};

--------------------------------------------------------------------------------
File Path: /codebase\backend\src\routes\auth.ts

import { Router, Request, Response, NextFunction } from "express";
import { prisma } from "../utils/prisma";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import { sendEventToKafka } from "../utils/producer";

const router = Router();

const CLIENT_ID = process.env.GITHUB_CLIENT_ID!;
const CLIENT_SECRET = process.env.GITHUB_CLIENT_SECRET!;
const REDIRECT_URI = "http://localhost:3000/phase2/githubtracker";

/* =====================================================
   TEMPORARY AUTH MIDDLEWARE (Skip real verification)
===================================================== */
function verifyToken(req: Request, res: Response, next: NextFunction) {
  try {
    console.log("Skipping JWT verification for testing");
    (req as any).user = { id: 1 }; // Simulate user
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token verification failed" });
  }
}

// helper to generate a random 6-character alphanumeric ID
function generateUserId() {
  const chars =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let id = "";
  for (let i = 0; i < 6; i++) {
    id += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return id;
}

router.post("/signup", async (req: Request, res: Response) => {
  try {
    const { email, password, name, phase } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: "Email and password required" });
    }

    const exists = await prisma.user.findUnique({ where: { email } });
    if (exists) {
      return res.status(409).json({ error: "Email already in use" });
    }

    const hash = await bcrypt.hash(password, 12);

    // generate unique 6-char userId (retry if collision)
    let userId: string;
    while (true) {
      userId = generateUserId();
      const existingId = await prisma.user.findUnique({ where: { userId } });
      if (!existingId) break; // ensure uniqueness
    }

    const newUser = await prisma.user.create({
      data: {
        email,
        name: name ?? "",
        password: hash,
        phase: phase ?? "1",
        userId, // added line
      },
      select: {
        id: true,
        email: true,
        name: true,
        phase: true,
        userId: true, // optional: include in response
      },
    });

    res.status(201).json({
      ok: true,
      message: "User created",
      user: newUser,
    });
  } catch (err) {
    console.error("Signup error:", err);
    res.status(500).json({ error: "Server error" });
  }
});

/* =====================================================
   Login Route
===================================================== */
router.post("/login", async (req: Request, res: Response) => {
  try {
    const { email, password } = req.body;
    if (!email || !password)
      return res.status(400).json({ error: "Email and password required" });

    const user = await prisma.user.findUnique({
      where: { email },
      select: {
        id: true,
        email: true,
        name: true,
        password: true,
        phase: true,
        userId: true,
      },
    });

    if (!user) return res.status(401).json({ error: "Invalid credentials" });

    const valid = await bcrypt.compare(password, user.password);
    if (!valid) return res.status(401).json({ error: "Invalid credentials" });

    // Generate JWT as before
    const token = jwt.sign(
      { id: user.id, email: user.email },
      process.env.JWT_SECRET!,
      { expiresIn: "7d" }
    );

    // Include phase in returned user object
    res.json({
      ok: true,
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        phase: user.phase,
        userId: user.userId, // Added here
      },
    });
  } catch (err) {
    console.error("Login error:", err);
    res.status(500).json({ error: "Server error" });
  }
});

/* =====================================================
   GitHub Data Fetch
===================================================== */
router.get("/github/data/:username", async (req: Request, res: Response) => {
  try {
    const { username } = req.params;
    const userId = req.query.userId || "guest"; // optional param for context

    if (!username)
      return res.status(400).json({ error: "GitHub username required" });

    // Fetch GitHub user profile
    const userResponse = await fetch(
      `https://api.github.com/users/${username}`
    );
    if (!userResponse.ok)
      return res
        .status(userResponse.status)
        .json({ error: await userResponse.text() });
    const userData = await userResponse.json();

    // Fetch repositories
    const repoResponse = await fetch(
      `https://api.github.com/users/${username}/repos`
    );
    const repos = await repoResponse.json();
    console.log("github fetched");

    // Build the payload to send to Kafka
    const payload = {
      userId,
      github: {
        profile: {
          username: userData.login,
          name: userData.name,
          bio: userData.bio,
          followers: userData.followers,
          following: userData.following,
          public_repos: userData.public_repos,
          location: userData.location,
          avatar_url: userData.avatar_url,
          html_url: userData.html_url,
        },
        repos: repos.map((r: any) => ({
          name: r.name,
          description: r.description,
          language: r.language,
          stargazers_count: r.stargazers_count,
          forks_count: r.forks_count,
          html_url: r.html_url,
          updated_at: r.updated_at,
        })),
      },
      timestamp: new Date().toISOString(),
    };

    // Send data to Kafka
    try {
      await sendEventToKafka(
        "github-tracker-events",
        userId as string,
        "githubTracker",
        payload
      );
      console.log(`Sent GitHub data for ${username} to Kafka pipeline`);
    } catch (kafkaErr) {
      console.error("Kafka pipeline send failed:", kafkaErr);
    }

    // Finally, respond to frontend
    res.json({ ok: true, user: userData, repos });
  } catch (err) {
    console.error("GitHub fetch error:", err);
    res.status(500).json({ error: "Failed to fetch GitHub data" });
  }
});
/* =====================================================
   LeetCode Data Fetch
===================================================== */
router.get("/leetcode/:username", async (req: Request, res: Response) => {
  const { username } = req.params;
  if (!username) return res.status(400).json({ error: "Username is required" });

  try {
    const response = await fetch(
      `https://leetcode-stats-api.herokuapp.com/${username}`
    );
    if (!response.ok)
      return res.status(500).json({ error: "Failed to fetch LeetCode data" });

    const data = await response.json();

    const formatted = {
      username: data.username || username,
      totalSolved: data.totalSolved || 0,
      totalQuestions: data.totalQuestions || 0,
      easySolved: data.easySolved || 0,
      totalEasy: data.totalEasy || 0,
      mediumSolved: data.mediumSolved || 0,
      totalMedium: data.totalMedium || 0,
      hardSolved: data.hardSolved || 0,
      totalHard: data.totalHard || 0,
      ranking: data.ranking || "N/A",
      contributionPoints: data.contributionPoints || 0,
      reputation: data.reputation || 0,
    };

    return res.json(formatted);
  } catch (err) {
    console.error("LeetCode API Error:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
});

/* =====================================================
    GET USER PROFILE
===================================================== */

export default router;

--------------------------------------------------------------------------------
File Path: /codebase\backend\src\routes\blogRoutes.ts

Error reading file: /codebase\backend\src\routes\blogRoutes.ts - 'charmap' codec can't decode byte 0x8f in position 281: character maps to <undefined>
File Path: /codebase\backend\src\routes\domainRoute.ts

Error reading file: /codebase\backend\src\routes\domainRoute.ts - 'charmap' codec can't decode byte 0x8f in position 531: character maps to <undefined>
File Path: /codebase\backend\src\routes\githubTracker.ts

Error reading file: /codebase\backend\src\routes\githubTracker.ts - 'charmap' codec can't decode byte 0x8f in position 203: character maps to <undefined>
File Path: /codebase\backend\src\routes\roadmap.route.ts

import { Router } from "express";
import { generateRoadmap, getAllRoadmaps, getRoadmapById } from "../controllers/roadmap.controller";
import { get } from "http";

const router = Router();

router.post("/generate", generateRoadmap);
router.get("/get/all", getAllRoadmaps);
router.get("/get/:id", getRoadmapById);

export default router;
--------------------------------------------------------------------------------
File Path: /codebase\backend\src\routes\timelineRoutes.ts

Error reading file: /codebase\backend\src\routes\timelineRoutes.ts - 'charmap' codec can't decode byte 0x9d in position 624: character maps to <undefined>
File Path: /codebase\backend\src\routes\trackerRoute.ts

Error reading file: /codebase\backend\src\routes\trackerRoute.ts - 'charmap' codec can't decode byte 0x9d in position 1001: character maps to <undefined>
File Path: /codebase\backend\src\services\kafkaConsumerService.ts

Error reading file: /codebase\backend\src\services\kafkaConsumerService.ts - 'charmap' codec can't decode byte 0x9d in position 1434: character maps to <undefined>
File Path: /codebase\backend\src\services\roadmap.service.ts

import { GoogleGenAI, ThinkingLevel } from "@google/genai";
import { transformToTree } from "../utils/roadmap.util";

// Helper function for sleeping between retries
const delay = (ms: number) => new Promise(res => setTimeout(res, ms));

export const roadmapService = {
  async generateAIContent(query: string, apiKey: string | undefined, modelName: string, retries = 3) {
    const ai = new GoogleGenAI(apiKey ? { apiKey } : {});

    for (let i = 0; i < retries; i++) {
      try {
        const systemInstruction = 
          "You are a helpful AI assistant that can generate career/syllabus roadmaps. You can arrange it in a way so that the order of the chapters is always from beginner to advanced. Always generate a minimum of 4 modules inside a chapter and a link to wikipedia if possible";

        const humanPrompt = 
          `Generate a roadmap in JSON format related to the title: ${query} which has the JSON structure: {query: ${query}, chapters: {chapterName: [{moduleName: string, moduleDescription: string, link?: string}]}} not in markdown format containing backticks. IMPORTANT: REFRAIN FROM ANSWERING ANY NSFW/DESTRUCTIVE/PROFANITY QUERY.`;

        const response = await ai.models.generateContent({
          model: modelName || "gemini-3-flash-preview", 
          config: {
            systemInstruction: systemInstruction,
            thinkingConfig: { thinkingLevel: ThinkingLevel.HIGH } 
          },
          contents: [{ role: "user", parts: [{ text: humanPrompt }] }]
        });

        const text = response.text;
        if (!text) throw new Error("AI returned empty response.");

        const rawContent = text.replace(/```json|```/g, "").trim();
        return transformToTree(query, JSON.parse(rawContent).chapters);

      } catch (error: any) {
        // If it's an overload (503) and we have retries left
        if (error.status === 503 && i < retries - 1) {
          console.warn(`Gemini overloaded (503). Retrying in ${2 * (i + 1)}s...`);
          await delay(2000 * (i + 1)); // Wait 2s, then 4s, etc.
          continue;
        }
        throw error; // If not 503 or no retries left, throw the error
      }
    }
  },
};
--------------------------------------------------------------------------------
File Path: /codebase\backend\src\utils\consumer.ts

Error reading file: /codebase\backend\src\utils\consumer.ts - 'charmap' codec can't decode byte 0x9d in position 985: character maps to <undefined>
File Path: /codebase\backend\src\utils\kafka.ts

import { Kafka } from "kafkajs";

export const kafka = new Kafka({
  clientId: "ascent-backend",
  brokers: ["localhost:9092"], // Adjust if using remote Kafka cluster
});

--------------------------------------------------------------------------------
File Path: /codebase\backend\src\utils\prisma.ts

import { PrismaClient } from "@prisma/client";

export const prisma = new PrismaClient();

--------------------------------------------------------------------------------
File Path: /codebase\backend\src\utils\producer.ts

import { Kafka, Producer, Message } from "kafkajs";

const kafka = new Kafka({
  clientId: "ascent-backend",
  brokers: [process.env.KAFKA_BROKER || "localhost:9092"],
});

let producer: Producer | null = null;

// Initialize and connect producer once
export const connectProducer = async () => {
  if (!producer) {
    producer = kafka.producer();
    await producer.connect();
    console.log("âœ… Kafka producer connected");
  }
  return producer;
};

// Helper: generic produce function for any topic
export const sendEventToKafka = async (
  topic: string,
  userId: string,
  feature: string,
  data: Record<string, any>
) => {
  if (!producer) {
    await connectProducer();
  }

  const message: Message = {
    key: userId, // ensures same partition per user
    value: JSON.stringify({
      userId,
      feature,
      data,
      timestamp: new Date().toISOString(),
    }),
  };

  await producer!.send({
    topic,
    messages: [message],
  });

  console.log(`ðŸ“¤ Sent event â†’ ${topic} | user: ${userId}`);
};

--------------------------------------------------------------------------------
File Path: /codebase\backend\src\utils\roadmap.util.ts

export const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);

export const cleanAIResponse = (text: string) => {
  // Removes markdown backticks if Gemini includes them
  return text.replace(/```json|```/g, "").trim();
};

export const transformToTree = (query: string, chapters: any) => {
  return {
    name: capitalize(query),
    children: Object.keys(chapters).map((chapterName) => ({
      name: chapterName,
      children: chapters[chapterName].map((module: any) => ({
        name: module.moduleName,
        moduleDescription: module.moduleDescription,
        link: module.link || `https://en.wikipedia.org/wiki/${encodeURIComponent(module.moduleName)}`,
      })),
    })),
  };
};
--------------------------------------------------------------------------------
File Path: /codebase\backend\src\utils\warmupKafka.ts

Error reading file: /codebase\backend\src\utils\warmupKafka.ts - 'charmap' codec can't decode byte 0x8f in position 738: character maps to <undefined>





